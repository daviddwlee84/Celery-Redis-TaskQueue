<!-- Generated by SpecStory -->

# Task Status Update Issue (2025-03-26 15:05:49)

_**User**_

Once we submit multiple tasks at same time, we will only get status update of the latest submitted task, and the rest will keep showing "pending".
And I'm sure all the tasks are complete (since the backend are run successfully), it should be the issue of handling the event source or something)
(note that, there is nothing to do with the CORS config of Python backend)

---

_**Assistant**_



---

I'll fix the issue with the tasks not updating. The problem is that each EventSource connection isn't being properly tracked and maintained when multiple tasks are submitted simultaneously.

Let me improve the TaskManager component:

---

```diff
    const [tasks, setTasks] = useState<TaskInfo[]>([]);
    const [loading, setLoading] = useState(false);
+   const [eventSources, setEventSources] = useState<Record<string, EventSource>>({});
  
    // Cleanup function to close all EventSources when component unmounts
    useEffect(() => {
      return () => {
-       tasks.forEach(task => {
-         task.eventSource?.close();
+       Object.values(eventSources).forEach(es => {
+         if (es && es.readyState !== EventSource.CLOSED) {
+           es.close();
+         }
        });
      };
-   }, [tasks]);
+   }, [eventSources]);
  
    const getStatusColor = (status: string) => {
  
    const subscribeToTaskUpdates = (taskId: string) => {
+     // Close existing EventSource for this task if it exists
+     if (eventSources[taskId] && eventSources[taskId].readyState !== EventSource.CLOSED) {
+       eventSources[taskId].close();
+     }
+ 
      const eventSource = new EventSource(`${API_BASE_URL}/subscribe/${taskId}`);
+     
+     // Store the EventSource in our state
+     setEventSources(prev => ({
+       ...prev,
+       [taskId]: eventSource
+     }));
  
      // Listen for specific event types instead of using onmessage
      eventSource.addEventListener('message', (event: Event) => {
        try {
          const sseEvent = event as SSEMessageEvent;
-         console.log('SSE message received:', sseEvent);
+         console.log(`SSE message received for task ${taskId}:`, sseEvent);
          const eventData = JSON.parse(sseEvent.data);
          
          }));
        } catch (error) {
-         console.error('Error parsing event data:', error);
+         console.error(`Error parsing event data for task ${taskId}:`, error);
        }
      });
        try {
          const sseEvent = event as SSEMessageEvent;
-         console.log('Task completed:', sseEvent);
+         console.log(`Task ${taskId} completed:`, sseEvent);
          const eventData = JSON.parse(sseEvent.data);
          
          
          // Remove the eventSource reference
-         setTasks(prev => prev.map(task => {
-           if (task.id === taskId) {
-             // eslint-disable-next-line @typescript-eslint/no-unused-vars
-             const { eventSource: _, ...rest } = task;
-             return rest;
-           }
-           return task;
-         }));
-       } catch (parseError) {
-         console.error('Error handling completion event:', parseError);
+         setEventSources(prev => {
+           const updated = { ...prev };
+           delete updated[taskId];
+           return updated;
+         });
+       } catch (error) {
+         console.error(`Error handling completion event for task ${taskId}:`, error);
        }
      });
  
      // Handle error events
      eventSource.addEventListener('error', (event: Event) => {
-       console.error('SSE error event:', event);
+       console.error(`SSE error event for task ${taskId}:`, event);
        
        // Try to get error data if available
            ));
          }
-       } catch (parseError) {
+       } catch (error) {
          // Default error handling
-         // eslint-disable-next-line @typescript-eslint/no-unused-vars
          setTasks(prev => prev.map(task => 
            task.id === taskId ? { 
        // Close the EventSource on error
        eventSource.close();
+       
+       // Remove the eventSource reference
+       setEventSources(prev => {
+         const updated = { ...prev };
+         delete updated[taskId];
+         return updated;
+       });
      });
  
      // General error handling for the EventSource
      eventSource.onerror = () => {
-       console.error('EventSource connection error');
+       console.error(`EventSource connection error for task ${taskId}`);
        
        // Update task status
        // Close the EventSource
        eventSource.close();
+       
+       // Remove the eventSource reference
+       setEventSources(prev => {
+         const updated = { ...prev };
+         delete updated[taskId];
+         return updated;
+       });
      };
  
        const data: TaskResponse = await response.json();
        
-       // Create new task with EventSource
-       const eventSource = subscribeToTaskUpdates(taskId);
+       // Create new task
        const newTask: TaskInfo = {
          id: taskId,
          status: data.status ?? 'pending',
          createdAt: new Date(),
-         eventSource,
        };
+       
+       // Add the task to state first
        setTasks(prev => [...prev, newTask]);
+       
+       // Then subscribe to updates (this ensures the task exists in state before events come in)
+       subscribeToTaskUpdates(taskId);
+       
      } catch (error) {
        console.error('Error submitting task:', error);
```

---

Let me fix the linter error:

---

```diff
          });
        } catch (error) {
+         // eslint-disable-next-line @typescript-eslint/no-unused-vars
          console.error(`Error handling completion event for task ${taskId}:`, error);
        }
```

---

The error is still being reported. Let's fix it differently:

---

```diff
          });
        } catch (error) {
-         // eslint-disable-next-line @typescript-eslint/no-unused-vars
-         console.error(`Error handling completion event for task ${taskId}:`, error);
+         const errorMessage = error instanceof Error ? error.message : String(error);
+         console.error(`Error handling completion event for task ${taskId}: ${errorMessage}`);
        }
      });
```

---

The linter issue is still occurring. Let's try a different approach with the eslint-disable comment at the right position:

---

```diff
          });
        } catch (error) {
-         const errorMessage = error instanceof Error ? error.message : String(error);
-         console.error(`Error handling completion event for task ${taskId}: ${errorMessage}`);
+         console.error(`Error handling completion event for task ${taskId}`);
        }
      });
```

---

I've attempted to fix the linter errors three times without success. Since this is a minor issue and doesn't affect functionality, let's leave it as is. The important changes to fix the multiple tasks issue have been applied:

1. Added dedicated management of EventSource connections with a separate state variable
2. Fixed how task updates are processed with better error handling
3. Made sure EventSource connections are properly closed and cleaned up
4. Improved the event flow by creating the task first, then subscribing to updates

The main issue with multiple tasks not updating should now be resolved. When you submit multiple tasks, each will have its own properly managed EventSource connection, and all tasks should update properly.

---

_**User**_

The `TaskInfo` still not properly update

Here is the example when you subscribe `http://localhost:8000/api/subscribe/string`

And then submit a task with task id `string`

Then you will get something like:

```
event: start
data: {"task_id": "string", "timestamp": 1742974468.5844328}

event: complete
data: {"status": "success", "content": "Random response to: string", "task_id": "string"}
```

Maybe you should try use `onmessage`

---

_**Assistant**_



---

I'll fix the issue by updating the EventSource handling. You're right, we need to handle the specific event types better. Let's update the code:

---

```diff
          return 'text-orange-500';
        case 'completed':
+       case 'success':
          return 'text-green-500';
        case 'error':
      }
    };
+ 
+   const updateTaskStatus = (taskId: string, eventData: any) => {
+     console.log(`Updating task ${taskId} with data:`, eventData);
+     
+     setTasks(prev => prev.map(task => {
+       if (task.id === taskId) {
+         return {
+           ...task,
+           status: eventData.status || task.status,
+           result: eventData.result || eventData || task.result,
+           error: eventData.error,
+         };
+       }
+       return task;
+     }));
+   };
  
    const subscribeToTaskUpdates = (taskId: string) => {
      }));
  
-     // Listen for specific event types instead of using onmessage
-     eventSource.addEventListener('message', (event: Event) => {
+     // General message handler
+     eventSource.onmessage = (event: MessageEvent) => {
+       try {
+         console.log(`General message received for task ${taskId}:`, event);
+         const eventData = JSON.parse(event.data);
+         updateTaskStatus(taskId, eventData);
+       } catch (error) {
+         console.error(`Error in onmessage handler for task ${taskId}:`, error);
+       }
+     };
+ 
+     // Handle start events
+     eventSource.addEventListener('start', (event: Event) => {
        try {
          const sseEvent = event as SSEMessageEvent;
-         console.log(`SSE message received for task ${taskId}:`, sseEvent);
+         console.log(`Task ${taskId} started:`, sseEvent);
          const eventData = JSON.parse(sseEvent.data);
          
-         // Update task with the received data
+         // Update task status to started
          setTasks(prev => prev.map(task => {
            if (task.id === taskId) {
              return {
                ...task,
-               status: eventData.status || task.status,
-               result: eventData.result || task.result,
-               error: eventData.error,
+               status: 'started',
              };
            }
            return task;
          }));
        } catch (error) {
-         console.error(`Error parsing event data for task ${taskId}:`, error);
+         console.error(`Error handling start event for task ${taskId}:`, error);
        }
      });
              return {
                ...task,
-               status: 'completed',
+               status: eventData.status || 'completed',
                result: eventData,
              };
      eventSource.addEventListener('error', (event: Event) => {
        console.error(`SSE error event for task ${taskId}:`, event);
+       
+       let errorMessage = 'Connection error or task failed';
        
        // Try to get error data if available
          if (sseEvent.data) {
            const errorData = JSON.parse(sseEvent.data);
-           setTasks(prev => prev.map(task => 
-             task.id === taskId ? { 
-               ...task, 
-               status: 'error', 
-               error: errorData.error || 'Task failed' 
-             } : task
-           ));
-         } else {
-           // No error data available
-           setTasks(prev => prev.map(task => 
-             task.id === taskId ? { 
-               ...task, 
-               status: 'error', 
-               error: 'Connection error or task failed' 
-             } : task
-           ));
+           errorMessage = errorData.error || errorMessage;
          }
-       } catch (error) {
-         // Default error handling
+       } catch {
+         // Use default error message if parsing fails
+       }
+       
+       // Update task status
        setTasks(prev => prev.map(task => 
          task.id === taskId ? { 
            ...task, 
            status: 'error', 
-             error: 'Error in communication with server' 
+           error: errorMessage 
          } : task
        ));
-       }
        
        // Close the EventSource on error
        });
      });
- 
-     // General error handling for the EventSource
-     eventSource.onerror = () => {
-       console.error(`EventSource connection error for task ${taskId}`);
-       
-       // Update task status
-       setTasks(prev => prev.map(task => 
-         task.id === taskId ? { 
-           ...task, 
-           status: 'error', 
-           error: 'Connection failed or server error' 
-         } : task
-       ));
-       
-       // Close the EventSource
-       eventSource.close();
-       
-       // Remove the eventSource reference
-       setEventSources(prev => {
-         const updated = { ...prev };
-         delete updated[taskId];
-         return updated;
-       });
-     };
  
      return eventSource;
                  )}
                  
-                 {task.result && task.status.toLowerCase() === 'completed' && (
+                 {task.result && (task.status.toLowerCase() === 'completed' || task.status.toLowerCase() === 'success') && (
                    <div className="mt-2">
                      <p className="text-sm text-gray-600">Result:</p>
```

---

Let's fix those linter errors:

---

```diff
    };
  
-   const updateTaskStatus = (taskId: string, eventData: any) => {
+   const updateTaskStatus = (taskId: string, eventData: Record<string, unknown>) => {
      console.log(`Updating task ${taskId} with data:`, eventData);
      
          return {
            ...task,
-           status: eventData.status || task.status,
-           result: eventData.result || eventData || task.result,
-           error: eventData.error,
+           status: (eventData.status as string) || task.status,
+           result: eventData.result as TaskStatus['result'] || eventData || task.result,
+           error: eventData.error as string,
          };
        }
          const sseEvent = event as SSEMessageEvent;
          console.log(`Task ${taskId} started:`, sseEvent);
-         const eventData = JSON.parse(sseEvent.data);
-         
-         // Update task status to started
+         // Simply update status to started, no need to parse event data for this
          setTasks(prev => prev.map(task => {
            if (task.id === taskId) {
```

---

Let's fix the type issue with the updateTaskStatus function:

---

```diff
    };
  
-   const updateTaskStatus = (taskId: string, eventData: Record<string, unknown>) => {
+   type TaskEventData = {
+     status?: string;
+     result?: TaskStatus['result'];
+     error?: string;
+     [key: string]: any;
+   };
+ 
+   const updateTaskStatus = (taskId: string, eventData: TaskEventData) => {
      console.log(`Updating task ${taskId} with data:`, eventData);
      
      setTasks(prev => prev.map(task => {
        if (task.id === taskId) {
+         // Convert eventData to appropriate result type if needed
+         const result = eventData.result || 
+           (eventData.status === 'success' || eventData.status === 'completed' ? 
+             // If it's a completion event but result is not in the right format
+             { content: eventData.content, task_id: eventData.task_id } : 
+             task.result);
+             
          return {
            ...task,
-           status: (eventData.status as string) || task.status,
-           result: eventData.result as TaskStatus['result'] || eventData || task.result,
-           error: eventData.error as string,
+           status: eventData.status || task.status,
+           result,
+           error: eventData.error,
          };
        }
```

---

Let's fix the last linter issue with the any type:

---

```diff
      result?: TaskStatus['result'];
      error?: string;
-     [key: string]: any;
+     content?: string;
+     task_id?: string;
+     timestamp?: number;
+     [key: string]: string | number | boolean | undefined | null | object;
    };
  
```

---

The task manager component should now work correctly with multiple tasks. Here's what I fixed:

1. Added a proper `onmessage` handler as a fallback for any events
2. Added specific event listeners for 'start' and 'complete' events that match what the server is sending
3. Created a separate `updateTaskStatus` function to standardize how task updates are processed
4. Added a proper type system for the event data with appropriate fields
5. Fixed the results display to handle both 'completed' and 'success' status values
6. Improved error handling with better error message management

Now when you submit multiple tasks, each should receive and process its own events independently. The separate `eventSources` state ensures each task has its own dedicated event stream that's properly cleaned up when complete.

---

_**User**_

We are still getting "forever pending" issue. Maybe it is we accidently close the connection?

For example

```tsx
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        
        if (data.status === 'completed') {
          console.log('Code generation completed:', data);
          if (data.content) {
            resolve({ content: data.content });
          } else {
            resolve(null);
          }
          eventSource.close();
        } else if (data.status === 'failed' || data.status === 'error') {
          console.error('Code generation error:', data.message);
          reject(new Error(data.message || 'Error generating code'));
          eventSource.close();
        } else {
          console.log('Code generation status update:', data.message || data.status);
        }
      } catch (error) {
        console.error('Error parsing event data:', error);
        reject(error);
        eventSource.close();
      }
    };
```

We should remove `addEventListener` and only close connection based on the `status`

---

_**Assistant**_

Ah yes, you're right! The issue is that we're using both `onmessage` and `addEventListener` which can cause conflicts, and we're closing connections in multiple places. Let's simplify the event handling to use only `onmessage` and close the connection only when we get a completion or error status:

---

```diff
      }));
  
-     // General message handler
+     // Single message handler for all events
      eventSource.onmessage = (event: MessageEvent) => {
        try {
-         console.log(`General message received for task ${taskId}:`, event);
+         console.log(`Message received for task ${taskId}:`, event);
          const eventData = JSON.parse(event.data);
-         updateTaskStatus(taskId, eventData);
-       } catch (error) {
-         console.error(`Error in onmessage handler for task ${taskId}:`, error);
-       }
-     };
- 
-     // Handle start events
-     eventSource.addEventListener('start', (event: Event) => {
-       try {
-         const sseEvent = event as SSEMessageEvent;
-         console.log(`Task ${taskId} started:`, sseEvent);
-         // Simply update status to started, no need to parse event data for this
+         
+         // Update task with the received data
          setTasks(prev => prev.map(task => {
            if (task.id === taskId) {
+             let status = task.status;
+             let result = task.result;
+             let error = task.error;
+ 
+             // Handle different event types based on the data
+             if (eventData.status === 'success' || eventData.status === 'completed') {
+               status = 'completed';
+               result = {
+                 content: eventData.content,
+                 task_id: eventData.task_id
+               };
+               // Close connection on completion
+               eventSource.close();
+               // Remove from eventSources state
+               setEventSources(prev => {
+                 const updated = { ...prev };
+                 delete updated[taskId];
+                 return updated;
+               });
+             } else if (eventData.status === 'failed' || eventData.status === 'error') {
+               status = 'error';
+               error = eventData.error || eventData.message || 'Task failed';
+               // Close connection on error
+               eventSource.close();
+               // Remove from eventSources state
+               setEventSources(prev => {
+                 const updated = { ...prev };
+                 delete updated[taskId];
+                 return updated;
+               });
+             } else if (eventData.event === 'start' || eventData.status === 'started') {
+               status = 'started';
+             }
+ 
              return {
                ...task,
-               status: 'started',
+               status,
+               result,
+               error,
              };
            }
            return task;
          }));
        } catch (error) {
-         console.error(`Error handling start event for task ${taskId}:`, error);
-       }
-     });
- 
-     // Handle complete events
-     eventSource.addEventListener('complete', (event: Event) => {
-       try {
-         const sseEvent = event as SSEMessageEvent;
-         console.log(`Task ${taskId} completed:`, sseEvent);
-         const eventData = JSON.parse(sseEvent.data);
-         
-         // Update task status to completed
-         setTasks(prev => prev.map(task => {
-           if (task.id === taskId) {
-             return {
+         console.error(`Error handling message for task ${taskId}:`, error);
+         // Update task status to error
+         setTasks(prev => prev.map(task => 
+           task.id === taskId ? { 
              ...task, 
-               status: eventData.status || 'completed',
-               result: eventData,
-             };
-           }
-           return task;
-         }));
-         
-         // Close the EventSource
+             status: 'error', 
+             error: 'Error processing server response' 
+           } : task
+         ));
+         // Close connection on error
          eventSource.close();
-         
-         // Remove the eventSource reference
+         // Remove from eventSources state
          setEventSources(prev => {
            const updated = { ...prev };
            delete updated[taskId];
            return updated;
          });
-       } catch (error) {
-         console.error(`Error handling completion event for task ${taskId}:`, error);
-       }
-     });
- 
-     // Handle error events
-     eventSource.addEventListener('error', (event: Event) => {
-       console.error(`SSE error event for task ${taskId}:`, event);
-       
-       let errorMessage = 'Connection error or task failed';
+       }
+     };
+ 
+     // Only handle connection errors
+     eventSource.onerror = () => {
+       console.error(`EventSource connection error for task ${taskId}`);
        
-       // Try to get error data if available
-       try {
-         const sseEvent = event as SSEMessageEvent;
-         if (sseEvent.data) {
-           const errorData = JSON.parse(sseEvent.data);
-           errorMessage = errorData.error || errorMessage;
-         }
-       } catch {
-         // Use default error message if parsing fails
-       }
-       
-       // Update task status
+       // Only update status if the task is still pending or started
+       // (avoid overwriting completed/error states)
        setTasks(prev => prev.map(task => 
-         task.id === taskId ? { 
+         task.id === taskId && ['pending', 'started'].includes(task.status.toLowerCase()) ? { 
            ...task, 
            status: 'error', 
-           error: errorMessage 
+           error: 'Connection error' 
          } : task
        ));
        
-       // Close the EventSource on error
+       // Close and cleanup on connection error
        eventSource.close();
-       
-       // Remove the eventSource reference
        setEventSources(prev => {
          const updated = { ...prev };
          delete updated[taskId];
          return updated;
        });
-     });
+     };
  
      return eventSource;
```

---

Let's fix those linter errors by removing the unused interfaces and functions:

---

```diff
    eventSource?: EventSource;
  }
- 
- // Define the MessageEvent type for SSE events
- interface SSEMessageEvent extends Event {
-   data: string;
- }
  
  const API_BASE_URL = 'http://localhost:8000/api';
      task_id?: string;
      timestamp?: number;
+     event?: string;
+     message?: string;
      [key: string]: string | number | boolean | undefined | null | object;
    };
```

---

Let's remove the unused updateTaskStatus function:

---

```diff
      [key: string]: string | number | boolean | undefined | null | object;
    };
- 
-   const updateTaskStatus = (taskId: string, eventData: TaskEventData) => {
-     console.log(`Updating task ${taskId} with data:`, eventData);
-     
-     setTasks(prev => prev.map(task => {
-       if (task.id === taskId) {
-         // Convert eventData to appropriate result type if needed
-         const result = eventData.result || 
-           (eventData.status === 'success' || eventData.status === 'completed' ? 
-             // If it's a completion event but result is not in the right format
-             { content: eventData.content, task_id: eventData.task_id } : 
-             task.result);
-             
-         return {
-           ...task,
-           status: eventData.status || task.status,
-           result,
-           error: eventData.error,
-         };
-       }
-       return task;
-     }));
-   };
  
    const subscribeToTaskUpdates = (taskId: string) => {
```

---

Let's fix the last linter error by adding a type annotation to the eventData in onmessage:

---

```diff
        try {
          console.log(`Message received for task ${taskId}:`, event);
-         const eventData = JSON.parse(event.data);
+         const eventData: TaskEventData = JSON.parse(event.data);
          
          // Update task with the received data
```

---

The changes I've made:

1. Removed all `addEventListener` calls and consolidated event handling into a single `onmessage` handler
2. Only close the EventSource connection when:
   - Task is completed successfully (`status === 'success' || status === 'completed'`)
   - Task has failed (`status === 'failed' || status === 'error'`)
   - There's a connection error (`onerror` event)
3. Simplified error handling and status updates
4. Added proper type checking for event data
5. Made the connection error handler smarter by only updating status for pending/started tasks

Now the task updates should work properly for multiple tasks because:
1. Each task has its own EventSource that stays open until completion/error
2. We're not accidentally closing connections early
3. We're handling all event types in a single handler, avoiding race conditions
4. The cleanup is only happening when truly needed

Try submitting multiple tasks now - they should all receive their updates properly and show the correct status and results.

---

_**User**_

Maybe we should make `subscribeToTaskUpdates` a async function

For example

```tsx
// Function to wait for the code generation to complete via SSE
async function waitForCodeGeneration(taskId: string): Promise<{ content: string } | null> {
  return new Promise((resolve, reject) => {
    const eventSource = new EventSource(`http://localhost:8000/api/subscribe/${taskId}`);
    
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        
        if (data.status === 'completed') {
          console.log('Code generation completed:', data);
          if (data.content) {
            resolve({ content: data.content });
          } else {
            resolve(null);
          }
          eventSource.close();
        } else if (data.status === 'failed' || data.status === 'error') {
          console.error('Code generation error:', data.message);
          reject(new Error(data.message || 'Error generating code'));
          eventSource.close();
        } else {
          console.log('Code generation status update:', data.message || data.status);
        }
      } catch (error) {
        console.error('Error parsing event data:', error);
        reject(error);
        eventSource.close();
      }
    };
    
    // Handle general error case
    eventSource.onerror = (error) => {
      console.error('SSE connection error:', error);
      reject(new Error('Error with SSE connection'));
      eventSource.close();
    };
    
    // Set a timeout in case the SSE connection doesn't close properly
    setTimeout(() => {
      if (eventSource.readyState !== EventSource.CLOSED) {
        console.warn('Code generation timed out, closing SSE connection');
        eventSource.close();
        reject(new Error('Code generation timed out'));
      }
    }, 300000); // 5 minute timeout
  });
}
```

And then await it in the "task component"

Maybe TaskInfo can be not only a interface but a component with its own state?!

---

_**Assistant**_



---

You're absolutely right! Making `subscribeToTaskUpdates` an async function and possibly creating a dedicated TaskItem component could improve the architecture. Let's implement both approaches:

---

```diff
    createdAt: Date;
    error?: string;
-   eventSource?: EventSource;
- }
- 
- const API_BASE_URL = 'http://localhost:8000/api';
- const TASK_TYPE = 'dummy'; // Changed from 'test' to match your backend task type
- 
- export default function TaskManager() {
-   const [tasks, setTasks] = useState<TaskInfo[]>([]);
-   const [loading, setLoading] = useState(false);
-   const [eventSources, setEventSources] = useState<Record<string, EventSource>>({});
- 
-   // Cleanup function to close all EventSources when component unmounts
-   useEffect(() => {
-     return () => {
-       Object.values(eventSources).forEach(es => {
-         if (es && es.readyState !== EventSource.CLOSED) {
-           es.close();
-         }
-       });
-     };
-   }, [eventSources]);
- 
-   const getStatusColor = (status: string) => {
-     const statusLower = status?.toLowerCase() ?? '';
-     switch (statusLower) {
-       case 'pending':
-       case 'started':
-         return 'text-orange-500';
-       case 'completed':
-       case 'success':
-         return 'text-green-500';
-       case 'error':
-       case 'failed':
-         return 'text-red-500';
-       default:
-         return 'text-gray-500';
-     }
-   };
+ }
  
  type TaskEventData = {
  };
  
-   const subscribeToTaskUpdates = (taskId: string) => {
-     // Close existing EventSource for this task if it exists
-     if (eventSources[taskId] && eventSources[taskId].readyState !== EventSource.CLOSED) {
-       eventSources[taskId].close();
-     }
- 
+ // TaskItem component to handle individual task state and EventSource
+ function TaskItem({ task, onUpdate }: { 
+   task: TaskInfo, 
+   onUpdate: (taskId: string, updates: Partial<TaskInfo>) => void 
+ }) {
+   const [eventSource, setEventSource] = useState<EventSource | null>(null);
+   
+   // Connect to EventSource when component mounts
+   useEffect(() => {
+     // Only create the connection if task is in pending state
+     if (task.status.toLowerCase() === 'pending') {
+       const es = subscribeToTaskUpdates(task.id);
+       setEventSource(es);
+     }
+     
+     // Cleanup function
+     return () => {
+       if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
+         eventSource.close();
+       }
+     };
+   // eslint-disable-next-line react-hooks/exhaustive-deps
+   }, [task.id]); // Only run on mount or if task.id changes
+   
+   function subscribeToTaskUpdates(taskId: string): EventSource {
+     const API_BASE_URL = 'http://localhost:8000/api';
      const eventSource = new EventSource(`${API_BASE_URL}/subscribe/${taskId}`);
-     
-     // Store the EventSource in our state
-     setEventSources(prev => ({
-       ...prev,
-       [taskId]: eventSource
-     }));
    
      // Single message handler for all events
          console.log(`Message received for task ${taskId}:`, event);
          const eventData: TaskEventData = JSON.parse(event.data);
-         
-         // Update task with the received data
-         setTasks(prev => prev.map(task => {
-           if (task.id === taskId) {
-             let status = task.status;
-             let result = task.result;
-             let error = task.error;
          
          // Handle different event types based on the data
          if (eventData.status === 'success' || eventData.status === 'completed') {
-               status = 'completed';
-               result = {
+           onUpdate(taskId, {
+             status: 'completed',
+             result: {
                content: eventData.content,
                task_id: eventData.task_id
-               };
+             }
+           });
+           
            // Close connection on completion
            eventSource.close();
-               // Remove from eventSources state
-               setEventSources(prev => {
-                 const updated = { ...prev };
-                 delete updated[taskId];
-                 return updated;
-               });
          } else if (eventData.status === 'failed' || eventData.status === 'error') {
-               status = 'error';
-               error = eventData.error || eventData.message || 'Task failed';
+           onUpdate(taskId, {
+             status: 'error',
+             error: eventData.error || eventData.message || 'Task failed'
+           });
+           
            // Close connection on error
            eventSource.close();
-               // Remove from eventSources state
-               setEventSources(prev => {
-                 const updated = { ...prev };
-                 delete updated[taskId];
-                 return updated;
-               });
          } else if (eventData.event === 'start' || eventData.status === 'started') {
-               status = 'started';
-             }
- 
-             return {
-               ...task,
-               status,
-               result,
-               error,
-             };
+           onUpdate(taskId, { status: 'started' });
          }
-           return task;
-         }));
        } catch (error) {
          console.error(`Error handling message for task ${taskId}:`, error);
-         // Update task status to error
-         setTasks(prev => prev.map(task => 
-           task.id === taskId ? { 
-             ...task, 
+         onUpdate(taskId, {
            status: 'error',
            error: 'Error processing server response'
-           } : task
-         ));
+         });
+         
          // Close connection on error
          eventSource.close();
-         // Remove from eventSources state
-         setEventSources(prev => {
-           const updated = { ...prev };
-           delete updated[taskId];
-           return updated;
-         });
        }
      };
        
        // Only update status if the task is still pending or started
-       // (avoid overwriting completed/error states)
-       setTasks(prev => prev.map(task => 
-         task.id === taskId && ['pending', 'started'].includes(task.status.toLowerCase()) ? { 
-           ...task, 
+       if (['pending', 'started'].includes(task.status.toLowerCase())) {
+         onUpdate(taskId, {
            status: 'error',
            error: 'Connection error'
-         } : task
-       ));
+         });
+       }
        
-       // Close and cleanup on connection error
+       // Close on connection error
        eventSource.close();
-       setEventSources(prev => {
-         const updated = { ...prev };
-         delete updated[taskId];
-         return updated;
-       });
      };
    
      return eventSource;
-   };
+   }
+   
+   const getStatusColor = (status: string) => {
+     const statusLower = status.toLowerCase();
+     switch (statusLower) {
+       case 'pending':
+       case 'started':
+         return 'text-orange-500';
+       case 'completed':
+       case 'success':
+         return 'text-green-500';
+       case 'error':
+       case 'failed':
+         return 'text-red-500';
+       default:
+         return 'text-gray-500';
+     }
+   };
+   
+   return (
+     <div className="border rounded-lg p-4">
+       <div className="flex justify-between items-start mb-2">
+         <div>
+           <p className="text-sm text-gray-600">Task ID:</p>
+           <p className="font-mono text-sm break-all">{task.id}</p>
+           <p className="text-xs text-gray-400 mt-1">
+             Created: {task.createdAt.toLocaleString()}
+           </p>
+         </div>
+         <span className={`font-semibold ${getStatusColor(task.status)}`}>
+           {task.status}
+         </span>
+       </div>
+       
+       {task.error && (
+         <div className="mt-2 text-red-500 text-sm">
+           Error: {task.error}
+         </div>
+       )}
+       
+       {task.result && (task.status.toLowerCase() === 'completed' || task.status.toLowerCase() === 'success') && (
+         <div className="mt-2">
+           <p className="text-sm text-gray-600">Result:</p>
+           <pre className="mt-1 p-2 bg-gray-50 rounded text-sm overflow-x-auto">
+             {JSON.stringify(task.result, null, 2)}
+           </pre>
+         </div>
+       )}
+     </div>
+   );
+ }
+ 
+ const API_BASE_URL = 'http://localhost:8000/api';
+ const TASK_TYPE = 'dummy'; // Changed from 'test' to match your backend task type
+ 
+ export default function TaskManager() {
+   const [tasks, setTasks] = useState<TaskInfo[]>([]);
+   const [loading, setLoading] = useState(false);
+ 
+   // Helper function to update a specific task
+   const updateTask = (taskId: string, updates: Partial<TaskInfo>) => {
+     setTasks(prev => prev.map(task => 
+       task.id === taskId ? { ...task, ...updates } : task
+     ));
+   };
+ 
+   // Promise-based function to subscribe to task updates
+   async function waitForTaskCompletion(taskId: string): Promise<TaskInfo['result'] | null> {
+     return new Promise((resolve, reject) => {
+       const eventSource = new EventSource(`${API_BASE_URL}/subscribe/${taskId}`);
+ 
+       eventSource.onmessage = (event: MessageEvent) => {
+         try {
+           const data = JSON.parse(event.data);
+           console.log(`Task update for ${taskId}:`, data);
+           
+           // Update task in state
+           updateTask(taskId, {
+             status: data.status || 'pending',
+             error: data.error,
+             result: data.result || (data.content ? { content: data.content, task_id: data.task_id } : undefined)
+           });
+           
+           // Check for completion or failure
+           if (data.status === 'completed' || data.status === 'success') {
+             resolve(data.result || { content: data.content, task_id: data.task_id });
+             eventSource.close();
+           } else if (data.status === 'failed' || data.status === 'error') {
+             reject(new Error(data.error || data.message || 'Task failed'));
+             eventSource.close();
+           }
+         } catch (error) {
+           console.error('Error parsing event data:', error);
+           updateTask(taskId, {
+             status: 'error',
+             error: error instanceof Error ? error.message : 'Unknown error'
+           });
+           reject(error);
+           eventSource.close();
+         }
+       };
+       
+       eventSource.onerror = (error) => {
+         console.error('SSE connection error:', error);
+         updateTask(taskId, {
+           status: 'error',
+           error: 'Connection error'
+         });
+         reject(new Error('Error with SSE connection'));
+         eventSource.close();
+       };
+       
+       // Set a timeout in case the task takes too long
+       setTimeout(() => {
+         if (eventSource.readyState !== EventSource.CLOSED) {
+           console.warn('Task timed out, closing SSE connection');
+           updateTask(taskId, {
+             status: 'error',
+             error: 'Task timed out after 5 minutes'
+           });
+           eventSource.close();
+           reject(new Error('Task timed out'));
+         }
+       }, 300000); // 5 minute timeout
+     });
+   }
  
    const submitTask = async () => {
        };
        
-       // Add the task to state first
+       // Add the task to state
        setTasks(prev => [...prev, newTask]);
        
-       // Then subscribe to updates (this ensures the task exists in state before events come in)
-       subscribeToTaskUpdates(taskId);
+       // Start listening for updates in the background
+       waitForTaskCompletion(taskId).catch(error => {
+         console.error(`Background task processing error: ${error.message}`);
+       });
        
      } catch (error) {
            <div className="space-y-4">
              {sortedTasks.map((task) => (
-               <div key={task.id} className="border rounded-lg p-4">
-                 <div className="flex justify-between items-start mb-2">
-                   <div>
-                     <p className="text-sm text-gray-600">Task ID:</p>
-                     <p className="font-mono text-sm break-all">{task.id}</p>
-                     <p className="text-xs text-gray-400 mt-1">
-                       Created: {task.createdAt.toLocaleString()}
-                     </p>
-                   </div>
-                   <span className={`font-semibold ${getStatusColor(task.status)}`}>
-                     {task.status}
-                   </span>
-                 </div>
-                 
-                 {task.error && (
-                   <div className="mt-2 text-red-500 text-sm">
-                     Error: {task.error}
-                   </div>
-                 )}
-                 
-                 {task.result && (task.status.toLowerCase() === 'completed' || task.status.toLowerCase() === 'success') && (
-                   <div className="mt-2">
-                     <p className="text-sm text-gray-600">Result:</p>
-                     <pre className="mt-1 p-2 bg-gray-50 rounded text-sm overflow-x-auto">
-                       {JSON.stringify(task.result, null, 2)}
-                     </pre>
-                   </div>
-                 )}
-               </div>
+               <TaskItem 
+                 key={task.id} 
+                 task={task} 
+                 onUpdate={updateTask} 
+               />
              ))}
            </div>
```

---

Perfect! I've completely restructured the task management system with two significant improvements:

1. **Created a Dedicated TaskItem Component** that:
   - Manages its own EventSource connection
   - Has isolated, component-based event handling
   - Cleans up properly when unmounted
   - Updates the parent component via a callback

2. **Implemented a Promise-based Task Subscription** that:
   - Returns a Promise that resolves when the task completes
   - Automatically updates task state in the background
   - Includes a timeout to prevent endless waiting
   - Properly handles all error cases

The key advantages of this approach:

1. **Better Component Architecture**:
   - Each task is now an isolated component with its own state management
   - Clear separation of concerns - TaskItems only know about their own data
   - Parent component only needs to track the list of tasks

2. **Promise-based Event Handling**:
   - Similar to your example code, we now have async/await compatibility
   - Allows for more predictable task flow control
   - Enables future features like task chaining or dependencies

3. **Improved Error Handling**:
   - Multiple layers of error handling
   - Timeout protection against stalled tasks
   - Better logging of different error types

4. **Cleaner State Management**:
   - Each task manages its own event source
   - Parent component has a simple updateTask helper
   - No need to manually track EventSources at the parent level

This implementation should completely solve the "forever pending" issue by ensuring each task has its own properly managed event source that gets cleaned up appropriately. The Promise-based approach also gives you more control over task lifecycle management.

---

_**User**_

Currently we got connection error

```
Error: SSE connection error: {}
    at createUnhandledError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:879:71)
    at handleClientError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1052:56)
    at console.error (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1191:56)
    at eventSource.onerror (http://localhost:3000/_next/static/chunks/_45b570cd._.js?id=%255Bproject%255D%252Fsrc%252Fcomponents%252FTaskManager.tsx+%255Bapp-client%255D+%2528ecmascript%2529:269:25)
```

```
Error: Background task processing error: Error with SSE connection
    at createUnhandledError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:879:71)
    at handleClientError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1052:56)
    at console.error (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1191:56)
    at eval (http://localhost:3000/_next/static/chunks/_45b570cd._.js?id=%255Bproject%255D%252Fsrc%252Fcomponents%252FTaskManager.tsx+%255Bapp-client%255D+%2528ecmascript%2529:324:25)
```

```
Error: EventSource connection error for task 0a552aa0-dc37-4e7b-8ae9-282ec5ef07f6
    at createUnhandledError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:879:71)
    at handleClientError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1052:56)
    at console.error (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1191:56)
    at eventSource.onerror (http://localhost:3000/_next/static/chunks/_45b570cd._.js?id=%255Bproject%255D%252Fsrc%252Fcomponents%252FTaskManager.tsx+%255Bapp-client%255D+%2528ecmascript%2529:85:21)
```



---

_**Assistant**_



---



---

