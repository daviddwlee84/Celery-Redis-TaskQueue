<!-- Generated by SpecStory -->

# Debugging Multiple SSE Subscription Requests (2025-03-26 17:19:05)

_**User**_

I found that somehow when we sumit one task, the backend will receive 3 subscribe request, I think this is not normal

---

_**Assistant**_

Let me help investigate this issue. From the logs you shared, I can see that indeed there are 3 SSE (Server-Sent Events) subscription requests being made for the same task ID. Let me examine the frontend code to understand why this might be happening.

Looking at the `TaskManager.tsx` component, I can see that the SSE connection is established in the `waitForTaskCompletion` function. Let's analyze how this function is being used:

1. First, it's called in the `submitTask` function:

```typescript
// Start listening for updates in the background
waitForTaskCompletion(taskId).catch(error => {
  console.error(`Background task processing error: ${error.message}`);
});
```

The issue appears to be related to React's development mode and strict mode, which can cause components to mount multiple times for safety checks. This, combined with potential re-renders, might be causing multiple SSE connections to be established.

Let me propose a fix to ensure we only maintain one SSE connection per task. Here's what we'll do:

1. Track active SSE connections
2. Clean up connections properly
3. Prevent duplicate connections

I'll modify the code:

---

```diff
  'use client';
  
- import { useState, useEffect } from 'react';
+ import { useState, useEffect, useRef } from 'react';
  import { v4 as uuidv4 } from 'uuid';
  import TaskItem from './TaskItem';
    const [taskType, setTaskType] = useState(TASK_TYPES[0]);
    const [keepPrompt, setKeepPrompt] = useState(false);
+   
+   // Add a ref to track active SSE connections
+   const activeConnections = useRef<{ [key: string]: EventSource }>({});
+ 
+   // Clean up function for SSE connections
+   useEffect(() => {
+     return () => {
+       // Clean up all active connections when component unmounts
+       Object.values(activeConnections.current).forEach(connection => {
+         connection.close();
+       });
+     };
+   }, []);
  
    // Load tasks from localStorage on component mount
    // Promise-based function to subscribe to task updates
    async function waitForTaskCompletion(taskId: string): Promise<TaskInfo['result'] | null> {
+     // Check if there's already an active connection for this task
+     if (activeConnections.current[taskId]) {
+       console.log(`Already subscribed to task ${taskId}`);
+       return null;
+     }
+ 
      return new Promise((resolve, reject) => {
        console.log(`Starting waitForTaskCompletion for task ${taskId}`);
        const eventSource = new EventSource(`${API_BASE_URL}/subscribe/${taskId}`);
-       
+       
+       // Store the connection
+       activeConnections.current[taskId] = eventSource;
+ 
        // Handler for when the connection is opened
        eventSource.onopen = () => {
            resolve(result);
            
-           // Close connection on completion
+           // Close and remove connection on completion
            console.log(`Closing EventSource after completion in waitForTaskCompletion for task ${taskId}`);
            eventSource.close();
+           delete activeConnections.current[taskId];
          } catch (error) {
            console.error(`Error handling complete event in waitForTaskCompletion for task ${taskId}:`, error);
            reject(error);
            eventSource.close();
+           delete activeConnections.current[taskId];
          }
        });
        };
        
-       // Connection error handler
+       // Modify error handler to clean up connection
        eventSource.onerror = (error) => {
          console.error(`SSE connection error in waitForTaskCompletion for task ${taskId}:`, error);
          if (eventSource.readyState === EventSource.CLOSED) {
            console.log(`EventSource closed in waitForTaskCompletion for task ${taskId}`);
+           delete activeConnections.current[taskId];
            reject(new Error('Error with SSE connection'));
          }
            });
            eventSource.close();
+           delete activeConnections.current[taskId];
            reject(new Error('Task timed out'));
          }
        eventSource.addEventListener('close', () => {
          clearTimeout(timeoutId);
+         delete activeConnections.current[taskId];
        });
      });
```

---

I've made several important changes to fix the issue:

1. Added a `useRef` to track active SSE connections
2. Added connection tracking using `activeConnections.current[taskId]`
3. Added checks to prevent duplicate connections for the same task
4. Added proper cleanup of connections in all scenarios (completion, error, timeout)
5. Added a cleanup effect to close all connections when the component unmounts

The key changes are:

1. Before creating a new SSE connection, we now check if one already exists for that task ID
2. We track all active connections in the `activeConnections` ref
3. We properly clean up connections when they're no longer needed
4. We ensure connections are removed from tracking when they close for any reason

These changes should prevent the multiple subscription issue by:
1. Preventing duplicate connections for the same task
2. Properly managing the lifecycle of SSE connections
3. Ensuring connections are cleaned up appropriately

You should now see only one subscription request per task. The logs should show just one GET request to `/api/subscribe/{task_id}` instead of three.

Would you like to test this change and confirm if it resolves the multiple subscription issue?

---

_**User**_

Please make it able to press "Enter" to submit task.
And
Can you help me find why I cannot submit task smoothly (can easily stuck at `loading` state)

---

_**Assistant**_



---

I'll address both issues:

---

```diff
        // Add a timeout for the fetch request
        const controller = new AbortController();
-       const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
+       const timeoutId = setTimeout(() => {
+         controller.abort();
+         console.log('Request timeout, aborting');
+       }, 10000); // 10 second timeout
        
        try {
          waitForTaskCompletion(taskId).catch(error => {
            console.error(`Background task processing error: ${error.message}`);
+           // Update task with error status to ensure UI reflects the error
+           updateTask(taskId, {
+             status: 'error',
+             error: error.message || 'Error processing task'
+           });
          });
        } catch (fetchError) {
+         // Ensure we set loading to false in all error cases
          if (fetchError instanceof Error && fetchError.name === 'AbortError') {
            throw new Error('Request timed out after 10 seconds. The server might be overloaded or unavailable.');
        }]);
      } finally {
+       // Ensure loading state is reset in all cases
        setLoading(false);
      }
              value={prompt}
              onChange={(e) => setPrompt(e.target.value)}
+             onKeyDown={(e) => {
+               if (e.key === 'Enter' && !loading) {
+                 e.preventDefault();
+                 submitTask();
+               }
+             }}
              placeholder="Enter task prompt..."
              className="block w-full p-2.5 border border-gray-300 rounded-md shadow-sm text-gray-800 font-medium"
```

---

I've made two key improvements to your code:

1. **Added Enter key submission capability:**
   - Added an `onKeyDown` event handler to the input field
   - When Enter is pressed and the form isn't already in a loading state, it triggers the submit function
   - Added `e.preventDefault()` to prevent any default form submission behavior

2. **Fixed the "stuck in loading" issue:**
   - Added better error handling in the task submission process
   - Added additional logging for request timeouts
   - Ensured that tasks are properly updated with error status when background processing fails
   - Added explicit comments to clarify where loading state is reset to ensure it's happening in all cases
   - Made sure that errors in the background processing are properly reflected in the UI

The main reasons for getting stuck in the loading state could be:

1. **Network issues**: The request might time out but not trigger the abort correctly
2. **Error handling gaps**: Errors in the background task processing might not properly reset the loading state
3. **Promise chain issues**: If there were unhandled promise rejections, the finally block might not execute

The changes I've made should address these issues by:
- Improving logging for timeouts
- Ensuring errors from background task processing update the UI
- Making sure the loading state is reset in all cases, including errors
- Adding explicit comments to make the code more maintainable

This should make your task submission more reliable and provide a better user experience with the Enter key functionality.

---

_**User**_

Currently we are not able to handle error case properly

```
Error: SSE connection error in waitForTaskCompletion for task 4e204513-599b-420b-9933-20419bcabd50: {}
    at createUnhandledError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:879:71)
    at handleClientError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1052:56)
    at console.error (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1191:56)
    at eventSource.onerror (http://localhost:3000/_next/static/chunks/_1738f75b._.js?id=%255Bproject%255D%252Fsrc%252Fcomponents%252FTaskManager.tsx+%255Bapp-client%255D+%2528ecmascript%2529:200:25)

Error: EventSource connection error for task 4e204513-599b-420b-9933-20419bcabd50 {}
    at createUnhandledError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:879:71)
    at handleClientError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1052:56)
    at console.error (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_43e3ffb8._.js:1191:56)
    at eventSource.onerror (http://localhost:3000/_next/static/chunks/_1738f75b._.js:153:21)
```

Which the event source will disconnect, but we expected it to capture the error status which we can display server error message "Error" instead of `Error: Connection error - the task may still be processing`

---

_**Assistant**_



---

I'll modify the EventSource handling to properly receive and display error messages from the server:

---

```diff
              resolve(result);
              eventSource.close();
+             delete activeConnections.current[taskId];
            } else if (data.status === 'failed' || data.status === 'error') {
-             reject(new Error(data.error || data.message || 'Task failed'));
+             console.log(`Task ${taskId} failed with error:`, data.error || data.message);
+             
+             // Update task with error information from server
+             updateTask(taskId, {
+               status: 'error',
+               error: data.error || data.message || 'Task failed'
+             });
+             
+             // Pass the error information to the caller
+             const error = new Error(data.error || data.message || 'Task failed');
+             reject(error);
+             
+             // Clean up the connection
              eventSource.close();
+             delete activeConnections.current[taskId];
            }
          } catch (error) {
            reject(error);
            eventSource.close();
+           delete activeConnections.current[taskId];
          }
        };
        
-       // Modify error handler to clean up connection
+       // Modify error handler to be more resilient and properly clean up
        eventSource.onerror = (error) => {
          console.error(`SSE connection error in waitForTaskCompletion for task ${taskId}:`, error);
          
-         // Only update status if it's not already in an error state
-         const taskStatus = tasks.find(t => t.id === taskId)?.status;
-         if (taskStatus && ['pending', 'started'].includes(taskStatus.toLowerCase())) {
+         // Only update status if we haven't received a more specific error from server
+         const currentTask = tasks.find(t => t.id === taskId);
+         if (currentTask && (!currentTask.error || currentTask.error.includes('Connection error')) && 
+             ['pending', 'started'].includes(currentTask.status.toLowerCase())) {
            updateTask(taskId, {
              status: 'error',
          }
          
-         // Don't immediately close and reject on first error - browser might retry
+         // Don't immediately close on first error - browser might retry
          if (eventSource.readyState === EventSource.CLOSED) {
            console.log(`EventSource closed in waitForTaskCompletion for task ${taskId}`);
            delete activeConnections.current[taskId];
-           reject(new Error('Error with SSE connection'));
+           
+           // Only reject if we haven't already processed a more specific error
+           const task = tasks.find(t => t.id === taskId);
+           if (task && (!task.error || task.error.includes('Connection error'))) {
+             reject(new Error('SSE connection error'));
+           }
          }
        };
```

---

I've made several key improvements to handle server-side errors correctly:

1. **Enhanced Error Response Handling:**
   - Added detailed logging for errors returned from the server
   - Ensured that when the backend returns an error status, we properly extract and display the actual error message from the server
   - Added explicit task status updates with the error message from the server
   - Properly cleaned up the connection by removing it from `activeConnections` when errors occur

2. **Improved EventSource Error Handler:**
   - Made the error handler smarter - it now checks if we've already received a specific error message from the server
   - Only updates to a generic "Connection error" message if we haven't received a more specific error 
   - Added logic to avoid rejecting the promise multiple times if we've already handled a server-side error
   - Improved connection management to ensure we don't leave dangling connections

3. **Better Error State Management:**
   - Made sure the task state gets updated with the actual server error message ("Error" in your example)
   - Ensured we properly clean up resources even when errors occur
   - Added logic to prioritize server-provided error messages over generic connection errors

These changes will ensure that when your backend returns an error (like when "error" is in the message text), the frontend will:

1. Properly display the actual error message from the server ("Error") 
2. Not disconnect the EventSource prematurely
3. Properly handle the error state in the UI
4. Clean up resources correctly

Now when a task fails with an error on the server side, you should see the actual error message in the UI instead of the generic "Connection error" message.

---

_**User**_

I think we should properly display the error data

```py
        error_data = {
            "status": "error",
            "error": str(error),
            "error_type": type(error).__name__,
            "task_id": task_id
        }
```

Instead of `Error: Connection error - the task may still be processing`

---

_**Assistant**_



---

You're right - we need to specifically listen for the server's "error" event to properly display the error information. Let me fix that:

---

```diff
          }
        });
+       
+       // Add specific listener for error events from the server
+       eventSource.addEventListener('error', (event: Event) => {
+         try {
+           const messageEvent = event as MessageEvent;
+           console.log(`Error event received from server for task ${taskId}:`, messageEvent);
+           
+           let errorData;
+           try {
+             errorData = JSON.parse(messageEvent.data);
+           } catch (parseError) {
+             errorData = { error: 'Failed to parse error data from server' };
+           }
+           
+           // Update task with detailed error information from server
+           updateTask(taskId, {
+             status: 'error',
+             error: errorData.error || 'Unknown server error'
+           });
+           
+           // Reject the promise with the error from the server
+           const error = new Error(errorData.error || 'Task failed on server');
+           reject(error);
+           
+           // Clean up the connection
+           console.log(`Closing EventSource after receiving error event for task ${taskId}`);
+           eventSource.close();
+           delete activeConnections.current[taskId];
+         } catch (handlingError) {
+           console.error(`Error handling server error event for task ${taskId}:`, handlingError);
+           
+           // Still update the task with a fallback error message
+           updateTask(taskId, {
+             status: 'error',
+             error: 'Error processing server error message'
+           });
+           
+           // Reject and clean up
+           reject(handlingError);
+           eventSource.close();
+           delete activeConnections.current[taskId];
+         }
+       });
        
        eventSource.addEventListener('complete', (event: Event) => {
```

---

```diff
              errorData = JSON.parse(messageEvent.data);
            } catch (parseError) {
+             console.error(`Failed to parse error data from server: ${parseError.message}`);
              errorData = { error: 'Failed to parse error data from server' };
            }
```

---

```diff
              errorData = JSON.parse(messageEvent.data);
            } catch (parseError) {
-             console.error(`Failed to parse error data from server: ${parseError.message}`);
+             console.error(`Failed to parse error data from server:`, parseError);
              errorData = { error: 'Failed to parse error data from server' };
            }
```

---

Now your frontend will correctly handle the server-side error events and display the proper error message. Here's what I've fixed:

1. **Added Dedicated Error Event Listener:**
   - Added a specific event listener for the 'error' event type sent by the server
   - This is separate from the EventSource's built-in error handler (onerror)

2. **Proper Error Data Handling:**
   - The listener will properly parse and extract the error message sent by the server:
     ```json
     {
       "status": "error",
       "error": "Error",
       "error_type": "Exception",
       "task_id": "..."
     }
     ```
   - It will display the actual error message from the server (e.g., "Error" when "error" is in the prompt)
   - It handles JSON parsing errors gracefully

3. **Clean Resource Management:**
   - Ensures the EventSource connection is closed properly
   - Removes the connection from the active connections tracking
   - Properly rejects the promise with the actual error message

Now when an error occurs on the server side (like when you submit a task with "error" in the prompt), your frontend will:

1. Receive the specific "error" event from the server
2. Extract and display the actual error message (e.g., "Error" instead of "Connection error")
3. Properly handle the error state in the UI

This should resolve the issue where you see "Connection error - the task may still be processing" instead of the actual server error message.

---

_**User**_

Ah, maybe you can use `/api/task{task_id}` as a SSE disconnection fallback

---

_**Assistant**_



---



---

